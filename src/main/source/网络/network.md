# 网络

TODO
---

* 各个协议

---


## 应用层协议:
-   **HTTP**:
    -   `Get和Post的区别`:
        -   都是tcp连接
        -   get回退是无害的,而post回退是有害的
        -   get请求会被浏览器主动cache,post不会
        -   get参数显示在url上,post在请求体中
-   **HTTPS**:
    -   本质上是HTTP+SSL
        -   什么是SSL: Security Socket layer: 传输层网络安全协议,加密数据
    -   流程大致为:
        * HTTPS的本质是http+ssl ,ssl在传输层对网络连接进行加密
    - 具体的流程如下:
        -   浏览器: `将自己的一套加密规则发给服务器`
        -   服务器: `服务器从加密规则中挑选出一组加密算法和HASH算法`,然后将生成的`公钥`以及一些信息包装成`证书发送给浏览器`
        -   浏览器: 浏览器接收到证书,`验证证书的合法性`,如果验证合法(或者提示不合法但是依旧相信这个证书),则`浏览器生成一串随机的字符串密码`,然后用公钥加密字符串生成`密钥`,然后HASH算法算出相关信息,随机数密码加密信息,最终会`携带密钥+加密后的数据+hash结果`一起发送给服务器
        -   服务器: 收到了密钥+加密后的数据,先用私钥解密密钥得到密码->密码解密数据->hash计算数据与送过来的hash结果进行匹对,匹对成功->使用密码加密一段握手信息,当然也会携带hash后的结果,发回给浏览器
        -   浏览器: 收到加密的握手信息->密码解密,然后hash计算->如果与服务器发送过来的hash结果一致,则表明是正确的服务器->`之后所有的数据都会用这个密码加密解密`
        -   总结就是: 先浏览器得到公钥生成密钥之后,与服务器联系验证其是否是"本人"

## 传输层协议:
* **TCP**
    * TCP头结构: ![](https://img-blog.csdnimg.cn/20190218154103542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyX0pva2Vy,size_16,color_FFFFFF,t_70)
        -   源目端口(16+16)
        -   SEQ(32): 序列化,代表要发送从哪开始的数据,为收到的包的ack+len
        -   ACK(32): 代表客户端发过来的包多少字节收到了
        -   头部长度(4)+保留位(6)+6个字符(SYN,ACK,FIN等)+窗口尺寸(16)
            -   头部长度: 表示tcp头部最长有多少个4字节,长度为4位,代表最大为15,则最长有15*4=60字节
            -   保留位: 和浅显,TCP3次握手,4次挥手就通过保留位
            -   窗口尺寸: 既发送窗口和接收窗口的概念(这2者其实是相同的,但是本质上是先有接收窗口再有发送窗口),nagla算法(是不是这个名字,忘了,延迟确认机制和慢启动,这里`需要自己去确定一下,TODO`)
        -   TCP校验和(16)+紧急指针(16):
            -   TCP校验和: 16位则最长为2^16=65535字节,包括首部和数据部分
            -   紧急指针(`WIP`)
        -   选项:最长为40字节,由上述的头部长度而定,当没有选项的时候,tcp头部20字节
        -   数据
    * `TCP`的三次握手:
        -   客户端: 客户端请求建立连接,发送sync=1的tcp数据包:SEQ=u ,SYNC_SEND状态
        -   服务器: 服务器收到客户端请求建立连接,回复SYN数据包并且也请求建立连接: SEQ=s, ACK=u+1,处于SYNC_RECV状态
        -   客户端: 客户端收到服务器的回复和请求,回复一个确认包:ACK=s+1, 两者进入`established`状态
        > * 疑惑:
        1 . 为什么是三次握手而不是两次握手:
        答: 这是因为连接建立是双方的,第二次握手完毕就结束的话,服务器并不确定客户端是否准备好了;
    * `TCP的四次挥手`:
        -   客户端: 客户端请求断开连接,发送FIN+SEQ=c 的数据包,处于FIN-WAIT-1状态
        -   服务器: 服务器收到客户端断开连接的请求,回送一个ACK数据包: ack=c+1,此时服务器处于CLOSE_WAIT状态,同时,因为此时双反还建立连接,客户端收到后进入FIN-WAIT-2状态
        -   服务器: 服务器也请求断开连接,发送FIN包: FIN+SEQ=s,此时服务器进入LAST-ACK状态
        -   客户端: 客户端收到服务器断开连接的请求后,发送响应包ack=s+1 ,此时客户端进入time-wait状态(`在此期间会等待2msl`) 等待服务器撤销tcb
        -   总结: 
            -   客户端状态的变更: FIN-WAIT-1=>FIN-WAIT-2=>TIME-WAIT
            -   服务器状态的变更: CLOSE-WAIT=>LAST-ACK
            
        > * 疑惑
            1 . 为什么是4次挥手,而不是三次其实本质问题是为什么第2,3次挥手要分开发送,当2,3次合并的时候会发现就是三次挥手,`原因在于:` 1.连接的建立是双方的,`单方面的提出分手是不可能直接分的`;2.**此时双方是还未断开连接的,可能有些数据是还未传递完毕的,等真正服务器消费结束了再关闭**
            2 . 为什么要等待2*msl(msl: 最长segment等待时间)
这个问题衍生如下子问题:
            * 为什么不是立马结束
                -   反证法,假设立马结束,再假设`网络阻塞`,使得这个ack回复包阻塞在网络中,而服务器长久没收到,`则会触发超时重传`,FIN数据包会重新发给客户端,而此时客户端`已经close`了,客户端会返回RST,而RST又会返回给上层系统,违背了tcp的可靠性
            * 为什么不是等待3*msl..偏偏要2*msl
                -   答案也很简单,这是因为这个时间能够确保server收到消息,3过长,1过小,2刚刚好
                

---
可能的面试题
---
* 在url上输入链接发生了什么
    -   http代表协议,后面的则代表域名地址
    -   dns解析域名对应的ip地址,这是一个递归调用的过程(浏览器缓存直至顶级域名服务器)
    -   tcp握手请求
        -   在这途中会经过arp缓存,通过ip查询mac地址
    -   三次握手完毕,发起http请求传输数据,服务器收到数据包之后层层解析,然后再层层包装响应数据返回给客户端

* session和cookie的区别:
    -   cookie存放在客户端上,而session存放在服务器
    -   cookie不安全,可以长时间存储于客户端上,session可以认为是会话cookie,从浏览器打开到关闭期间会一直存在(当然不是立即没有的,并且浏览器开着需要活动才有效)
    -   cookie存储数据量有限,session受限于服务器内存